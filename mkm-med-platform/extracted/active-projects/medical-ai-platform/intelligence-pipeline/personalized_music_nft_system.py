üåü Ï¥àÍ∞úÏù∏Ìôî ÏùåÏïÖ NFT ÏãúÏä§ÌÖú
Í∞úÏù∏Ïùò ÏÉùÏ≤¥Îç∞Ïù¥ÌÑ∞, Î¨∏ÌôîÏ†Å Î∞∞Í≤Ω, ÏÇ¨ÌöåÏ†Å Îß•ÎùΩ, ÎØ∏ÏÑ∏ÌëúÏ†ï, ÏùåÏÑ±Ïã†Ìò∏Î•º Í≤∞Ìï©ÌïòÏó¨
Í≥†Ïú†Ìïú ÏùåÏïÖÏùÑ ÏÉùÏÑ±ÌïòÍ≥† NFTÎ°ú Î∞úÌñâÌïòÎäî ÏãúÏä§ÌÖúimport json
import time
import hashlib
from datetime import datetime
from typing import Dict, List, Any, Optional
import numpy as np
from dataclasses import dataclass

@dataclass
class BiometricData:
    Ïù¥ÌÑ∞ Íµ¨Ï°∞ heart_rate: float
    hrv: float
    stress_level: float
    energy_level: float
    sleep_quality: float
    blood_pressure_systolic: float
    blood_pressure_diastolic: float
    body_temperature: float
    respiration_rate: float
    skin_conductance: float

@dataclass
class CulturalData:
   Î¨∏ÌôîÏ†Å Î∞∞Í≤Ω Îç∞Ïù¥ÌÑ∞  nationality: str
    cultural_heritage: List[str]
    musical_preferences: List[str]
    traditional_instruments: Liststr]
    cultural_rhythms: List[str]
    spiritual_beliefs: Liststr]
    language: str
    region: str

@dataclass
class SocialContext:
   ÏÇ¨ÌöåÏ†Å Îß•ÎùΩ Îç∞Ïù¥ÌÑ∞    age_group: str
    occupation: str
    education_level: str
    social_status: str
    relationship_status: str
    family_role: str
    community_involvement: float
    social_network_size: int
    life_stage: str

@dataclass
class FacialExpressionData:
    ÌÑ∞"""
    happiness_level: float
    stress_indicators: float
    emotional_stability: float
    confidence_level: float
    focus_level: float
    micro_expressions: Dict[str, float]
    facial_muscle_tension: Dict[str, float]

@dataclass
class VoiceSignalData:
    Ìò∏ Îç∞Ïù¥ÌÑ∞"""
    pitch_frequency: float
    speech_rate: float
    voice_quality: str
    emotional_tone: str
    stress_indicators: float
    vocal_range: Dict[str, float]
    speech_patterns: Dict[str, float]

class PersonalizedMusicGenerator:
    Ïù∏Ìôî ÏùåÏïÖ ÏÉùÏÑ±Í∏∞"   
    def __init__(self):
        self.musical_scales = {
            korean: ['C',D',E',F, 'G', 'A',B'],
            western: ['C',D',E',F, 'G', 'A',B],          eastern: C, D, E, F#, 'G', 'A',B'],
           meditative: ['C',D',E', F, 'G', A, 'Bb']
        }
        
        self.rhythm_patterns = {
            korean': 4,4 #4          western': 4,4 # 4          eastern': 3,3 #3Ïûê
            meditative: 6, 6, 6,6  # 6Î∞ïÏûê
        }
        
        self.instrument_mapping = {
            korean:gayageum', daegeum, janggu', 'piri'],
            western:piano', violin, cello', 'flute],          eastern': ['sitar',tabla, 'bansuri', 'tanpura'],
          meditative': ['singing_bowl', chimes', drone',nature_sounds]        }
    
    def generate_personalized_music(self, 
                                  biometric: BiometricData,
                                  cultural: CulturalData,
                                  social: SocialContext,
                                  facial: FacialExpressionData,
                                  voice: VoiceSignalData,
                                  user_intention: str) -> Dict[str, Any]:
       ÏùåÏïÖ ÏÉùÏÑ±""        
        # 1. ÏùåÏïÖ Ïä§ÌÉÄÏùº Í≤∞Ï†ï
        music_style = self._determine_music_style(cultural, social, biometric)
        
        # 2. ÏùåÍ≥Ñ Í≤∞Ï†ï
        scale = self._determine_scale(biometric, facial, voice)
        
        # 3. Î¶¨Îì¨ Ìå®ÌÑ¥ Í≤∞Ï†ï
        rhythm = self._determine_rhythm(biometric, cultural, social)
        
        # 4. ÏïÖÍ∏∞ Ï°∞Ìï© Í≤∞Ï†ï
        instruments = self._determine_instruments(cultural, social, user_intention)
        
        # 5. ÌÖúÌè¨ Í≤∞Ï†ï
        tempo = self._determine_tempo(biometric, facial, voice)
        
        # 6. Í∞êÏ†ïÏ†Å ÌÜ§ Í≤∞Ï†ï
        emotional_tone = self._determine_emotional_tone(facial, voice, biometric)
        
        # 7. ÏùåÏïÖ Íµ¨Ï°∞ ÏÉùÏÑ±
        structure = self._generate_music_structure(user_intention, biometric)
        
        # 8. Í∞úÏù∏ÌôîÎêú Î©úÎ°úÎîî ÏÉùÏÑ±
        melody = self._generate_personalized_melody(scale, rhythm, emotional_tone)
        
        #9ÏÉùÏÑ±
        harmony = self._generate_harmony(melody, emotional_tone)
        
        # 10. ÏùåÏïÖ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        metadata = self._generate_music_metadata(
            biometric, cultural, social, facial, voice, user_intention
        )
        
        return {
        music_style': music_style,
          scalescale,
            rhythmhythm,
        instruments': instruments,
          tempotempo,
           emotional_tone': emotional_tone,
      structure': structure,
            melodyelody,
            harmony': harmony,
     metadata': metadata,
       generation_timestamp:datetime.now().isoformat(),
           unique_signature': self._generate_unique_signature(
                biometric, cultural, social, facial, voice, user_intention
            )
        }
    
    def _determine_music_style(self, cultural: CulturalData, 
                             social: SocialContext, 
                             biometric: BiometricData) -> str:
       Ïä§ÌÉÄÏùº Í≤∞Ï†ï"      style_scores = {
       korean': 0,
        western':0      eastern': 0,
          meditative': 0
        }
        
        # Î¨∏ÌôîÏ†Å Î∞∞Í≤Ω Í∏∞Î∞ò
        if 'korean' in cultural.cultural_heritage:
            style_scores['korean] += 3
        if 'western' in cultural.cultural_heritage:
            style_scores['western] += 3
        if 'eastern' in cultural.cultural_heritage:
            style_scores['eastern'] += 3        
        # ÏÉùÏ≤¥Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò
        if biometric.stress_level > 0.7:
            style_scoresmeditative] += 2      if biometric.energy_level > 0.8:
            style_scores['korean'] += 1
            style_scores['western'] += 1        
        # ÏÇ¨ÌöåÏ†Å Îß•ÎùΩ Í∏∞Î∞ò
        if social.age_group in ['20s', '30
            style_scores['western] += 1
        if social.life_stage ==meditation_practitioner':
            style_scoresmeditative'] += 2   
        return max(style_scores, key=style_scores.get)
    
    def _determine_scale(self, biometric: BiometricData, 
                        facial: FacialExpressionData, 
                        voice: VoiceSignalData) -> Liststr]:
  Í≤∞Ï†ï"""
        base_scale = self.musical_scales['western']
        
        # Ïä§Ìä∏Î†àÏä§ Î†àÎ≤®Ïóê Îî∞Î•∏ Ï°∞Ï†ï
        if biometric.stress_level > 07:
            # ÌèâÏò®Ìïú ÏùåÍ≥ÑÎ°ú Ï°∞Ï†ï
            scale_adjustments = 0 2, 4 5, 7, 9 # Î©îÏù¥Ï†Ä Ïä§ÏºÄÏùº
        elif biometric.energy_level > 08:
            # ÌôúÍ∏∞Ï∞¨ ÏùåÍ≥ÑÎ°ú Ï°∞Ï†ï
            scale_adjustments = 0 2, 4 5, 7, 9 # Î©îÏù¥Ï†Ä Ïä§ÏºÄÏùº
        else:
            # Í∑†ÌòïÏû°Ìûå ÏùåÍ≥Ñ
            scale_adjustments = 0 2, 3 5, 7,8 ÎßàÏù¥ÎÑà Ïä§ÏºÄÏùº
        
        return [base_scale[i % len(base_scale)] for i in scale_adjustments]
    
    def _determine_rhythm(self, biometric: BiometricData, 
                         cultural: CulturalData, 
                         social: SocialContext) -> Listint]:
     Îì¨ Ìå®ÌÑ¥ Í≤∞Ï†ï"       base_rhythm = self.rhythm_patterns['western']
        
        # ÏÉùÏ≤¥Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Î¶¨Îì¨ Ï°∞Ï†ï
        if biometric.heart_rate >80:
            # Îπ†Î•∏ Î¶¨Îì¨
            return [2, 2, 2    elif biometric.stress_level > 06:
            # ÎäêÎ¶∞ Î¶¨Îì¨
            return [6, 6, 66 else:
            return base_rhythm
    
    def _determine_instruments(self, cultural: CulturalData, 
                             social: SocialContext, 
                             user_intention: str) -> Liststr]:
     Í∏∞ Ï°∞Ìï© Í≤∞Ï†ï"""
        instruments = []
        
        # Î¨∏ÌôîÏ†Å Î∞∞Í≤Ω Í∏∞Î∞ò
        if 'korean' in cultural.cultural_heritage:
            instruments.extend(self.instrument_mapping['korean'][:2])
        
        # ÏÇ¨Ïö©Ïûê ÏùòÎèÑ Í∏∞Î∞ò
        if 'ÌèâÌôî' in user_intention or 'Î™ÖÏÉÅ' in user_intention:
            instruments.extend(self.instrument_mapping['meditative'][:2])
        elif 'ÌôúÎ†•' in user_intention orÏóêÎÑàÏßÄ in user_intention:
            instruments.extend(self.instrument_mapping['western'][:2])
        
        # Ï§ëÎ≥µ Ï†úÍ±∞
        return list(set(instruments))
    
    def _determine_tempo(self, biometric: BiometricData, 
                        facial: FacialExpressionData, 
                        voice: VoiceSignalData) -> int:
        Ï†ï (BPM)        base_tempo = 120        
        # ÏÉùÏ≤¥Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Ï°∞Ï†ï
        if biometric.heart_rate > 80:
            base_tempo += 20
        elif biometric.stress_level > 0.7:
            base_tempo -= 30        
        # ÏùåÏÑ±Ïã†Ìò∏ Í∏∞Î∞ò Ï°∞Ï†ï
        if voice.speech_rate > 150:  # Îπ†Î•∏ ÎßêÌïòÍ∏∞
            base_tempo += 15
        elif voice.speech_rate < 100:  # ÎäêÎ¶∞ ÎßêÌïòÍ∏∞
            base_tempo -= 15   
        return max(60in(180, base_tempo))  # 6080PM Î≤îÏúÑ
    
    def _determine_emotional_tone(self, facial: FacialExpressionData, 
                                voice: VoiceSignalData, 
                                biometric: BiometricData) -> str:
     Ï†ïÏ†Å ÌÜ§ Í≤∞Ï†ï"""
        happiness = facial.happiness_level
        stress = biometric.stress_level
        voice_emotion = voice.emotional_tone
        
        if happiness > 0.7and stress < 0.3:
            return 'joyful'
        elif stress > 0.7:
            returncalming'
        elif voice_emotion == 'confident':
            return 'empowering'
        else:
            return 'balanced'
    
    def _generate_music_structure(self, user_intention: str, 
                                biometric: BiometricData) -> Dict[str, Any]:
     ÏïÖ Íµ¨Ï°∞ ÏÉùÏÑ±        if 'Î™ÖÏÉÅ' in user_intention or biometric.stress_level > 0.6:
            return[object Object]
                intro': 30,  # 30
                development': 60,  # 60
               climax': 30,  # 30
                resolution': 45,  # 45
                total_duration': 165  # 245         }
        else:
            return[object Object]
           intro0
               development': 40
            climax5
                resolution5
                total_duration': 120  #2           }
    
    def _generate_personalized_melody(self, scale: List[str], 
                                    rhythm: List[int], 
                                    emotional_tone: str) -> List[Dict[str, Any]]:
         Î©úÎ°úÎîî ÏÉùÏÑ±      melody = []
        
        for i, beat in enumerate(rhythm):
            # Í∞êÏ†ïÏ†Å ÌÜ§Ïóê Îî∞Î•∏ Ïùå ÏÑ†ÌÉù
            if emotional_tone == 'joyful:              note_index = (i * 2) % len(scale)
            elif emotional_tone == 'calming:              note_index = (i * 3) % len(scale)
            else:
                note_index = i % len(scale)
            
            melody.append({
                note: scale[note_index],
                durationt,
               velocity:80 if emotional_tone == joyful0
          octave':4      })
        
        return melody
    
    def _generate_harmony(self, melody: List[Dict[str, Any]], 
                         emotional_tone: str) -> List[Dict[str, Any]]:
   ÌïòÎ™®Îãà ÏÉùÏÑ±
        harmony = []
        
        for note in melody:
            # 3ÌôîÏùå ÌïòÎ™®Îãà ÏÉùÏÑ±
            if emotional_tone == 'joyful:             chord_type = 'major    elif emotional_tone == 'calming:             chord_type = 'minor            else:
                chord_type = 'suspended'
            
            harmony.append({
           chord_type': chord_type,
               root_note': note['note'],
                duration': note['duration'],
             inversion':0      })
        
        return harmony
    
    def _generate_music_metadata(self, biometric: BiometricData, 
                               cultural: CulturalData, 
                               social: SocialContext, 
                               facial: FacialExpressionData, 
                               voice: VoiceSignalData, 
                               user_intention: str) -> Dict[str, Any]:
        ÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        return {
     title': fPersonal Symphony for {user_intention}",
            artist: f"AI Composer - {cultural.nationality} Heritage",
     genre': f"Personalized [object Object]cultural.cultural_heritage[0] if cultural.cultural_heritage else Globalusic",
        mood: self._determine_emotional_tone(facial, voice, biometric),
         energy_level': biometric.energy_level,
         stress_level': biometric.stress_level,
            cultural_elements': cultural.cultural_heritage,
           social_context': social.life_stage,
      generation_parameters':[object Object]
           heart_rate: biometric.heart_rate,
                hrv: biometric.hrv,
                happiness_level': facial.happiness_level,
              voice_quality': voice.voice_quality,
               user_intention: user_intention
            }
        }
    
    def _generate_unique_signature(self, biometric: BiometricData, 
                                 cultural: CulturalData, 
                                 social: SocialContext, 
                                 facial: FacialExpressionData, 
                                 voice: VoiceSignalData, 
                                 user_intention: str) -> str:
     Ïú† ÏÑúÎ™Ö ÏÉùÏÑ±"""
        signature_data =[object Object]       biometric_hash: hashlib.md5r(biometric.__dict__).encode()).hexdigest(),
          cultural_hash: hashlib.md5(str(cultural.__dict__).encode()).hexdigest(),
            social_hash: hashlib.md5(str(social.__dict__).encode()).hexdigest(),
            facial_hash: hashlib.md5(str(facial.__dict__).encode()).hexdigest(),
           voice_hash: hashlib.md5str(voice.__dict__).encode()).hexdigest(),
           intention_hash': hashlib.md5(user_intention.encode()).hexdigest(),
      timestamp:datetime.now().isoformat()
        }
        
        return hashlib.sha256on.dumps(signature_data, sort_keys=True).encode()).hexdigest()

class MusicNFTManager:
   ÏïÖ NFT Í¥ÄÎ¶¨Ïûê"   
    def __init__(self):
        self.nft_collection = {}
        self.ownership_shares =[object Object]        self.music_generator = PersonalizedMusicGenerator()
    
    def create_music_nft(self, 
                        user_id: str,
                        biometric: BiometricData,
                        cultural: CulturalData,
                        social: SocialContext,
                        facial: FacialExpressionData,
                        voice: VoiceSignalData,
                        user_intention: str,
                        ownership_structure: Dict[str, float]) -> Dict[str, Any]:
      FT ÏÉùÏÑ±""        
        # Í∞úÏù∏ÌôîÎêú ÏùåÏïÖ ÏÉùÏÑ±
        music_data = self.music_generator.generate_personalized_music(
            biometric, cultural, social, facial, voice, user_intention
        )
        
        # NFT Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        nft_id = f"MUSIC_NFT_{user_id}_{int(time.time())}        
        nft_metadata = [object Object]           nft_idft_id,
            user_id': user_id,
       music_data': music_data,
       ownership_structure': ownership_structure,
     creation_timestamp:datetime.now().isoformat(),
         total_shares': sum(ownership_structure.values()),
      royalty_percentage:2.55 Î°úÏó¥Ìã∞
           license_type': 'personal_use',
            commercial_rights': False,
         transferable': True,
      fractional_ownership: True       }
        
        # NFT Ï†ÄÏû•
        self.nft_collection[nft_id] = nft_metadata
        self.ownership_shares[nft_id] = ownership_structure
        
        return nft_metadata
    
    def get_nft_info(self, nft_id: str) -> Optional[Dict[str, Any]]:
      T Ï†ïÎ≥¥ Ï°∞Ìöå       return self.nft_collection.get(nft_id)
    
    def transfer_ownership(self, nft_id: str, 
                         from_user: str, 
                         to_user: str, 
                         shares: float) -> bool:
   ÏÜåÏú†Í∂å Ïù¥Ï†Ñ
        if nft_id not in self.ownership_shares:
            return False
        
        current_shares = self.ownership_shares[nft_id]
        if from_user not in current_shares or current_shares[from_user] < shares:
            return False
        
        # ÏÜåÏú†Í∂å Ïù¥Ï†Ñ
        current_shares[from_user] -= shares
        if current_shares[from_user] <= 0       del current_shares[from_user]
        
        current_shares[to_user] = current_shares.get(to_user, 0) + shares
        
        returntrue
    def calculate_royalties(self, nft_id: str, 
                          transaction_amount: float) -> Dict[str, float]:
   Î°úÏó¥Ìã∞ Í≥ÑÏÇ∞
        if nft_id not in self.nft_collection:
            return {}
        
        nft_data = self.nft_collection[nft_id]
        ownership = self.ownership_shares[nft_id]
        royalty_rate = nft_data['royalty_percentage] / 100    
        total_royalty = transaction_amount * royalty_rate
        royalties = {}
        
        for owner, shares in ownership.items():
            total_shares = nft_data['total_shares']
            owner_royalty = (shares / total_shares) * total_royalty
            royalties[owner] = owner_royalty
        
        return royalties
    
    def get_user_nfts(self, user_id: str) -> List[Dict[str, Any]]:
       ÏÇ¨Ïö©ÏûêÏùò NFT Î™©Î°ù Ï°∞Ìöå
        user_nfts = []
        
        for nft_id, nft_data in self.nft_collection.items():
            if nft_id in self.ownership_shares:
                ownership = self.ownership_shares[nft_id]
                if user_id in ownership:
                    user_nfts.append({
                        nft_id          shares': ownership[user_id],
                       total_shares:nft_datatotal_shares               ownership_percentage:(ownership[user_id] / nft_data[total_shares']) * 100,
                       music_data: nft_data['music_data']
                    })
        
        return user_nfts

# ÏÇ¨Ïö© ÏòàÏãú
def demo_personalized_music_nft():
   Îç∞Î™® Ïã§Ìñâ"""
    
    # ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    biometric = BiometricData(
        heart_rate=72.0,
        hrv=650      stress_level=00.3      energy_level=00.7     sleep_quality=08    blood_pressure_systolic=1200    blood_pressure_diastolic=800  body_temperature=36.5,
        respiration_rate=16      skin_conductance=5
    
    cultural = CulturalData(
        nationality="Korean",
        cultural_heritage=[korean", "eastern"],
        musical_preferences=["traditional, itative"],
        traditional_instruments=[gayageum", "daegeum"],
        cultural_rhythms=["4/4, 
        spiritual_beliefs=["buddhism", taoism,
        language="Korean",
        region="Seoul"
    )
    
    social = SocialContext(
        age_group="30s",
        occupation=software_engineer",
        education_level="bachelor",
        social_status="middle_class",
        relationship_status="single",
        family_role="independent",
        community_involvement=0.6    social_network_size=150        life_stage="career_focused"
    )
    
    facial = FacialExpressionData(
        happiness_level=0.7      stress_indicators=0.2,
        emotional_stability=0.8,
        confidence_level=0.6       focus_level=0.9
        micro_expressions={smile":0.8, eye_contact": 0.7,
        facial_muscle_tension={"jaw": 0.3forehead": 00.2  )
    
    voice = VoiceSignalData(
        pitch_frequency=2200       speech_rate=1200     voice_quality="clear",
        emotional_tone="confident,      stress_indicators=0.2       vocal_range={"low:200, "high: 800.0    speech_patterns={"pace: oderate", "clarity": "high"}
    )
    
    # NFT Îß§ÎãàÏ†Ä ÏÉùÏÑ±
    nft_manager = MusicNFTManager()
    
    # ÏÜåÏú†Í∂å Íµ¨Ï°∞ Ï†ïÏùò (ÏßÄÎ∂Ñ Î∂ÑÌï†)
    ownership_structure = {
        user_123:60 # ÏÇ¨Ïö©Ïûê 60      ai_composer: 200AI ÏûëÍ≥°Í∞Ä 20%
       cultural_fund": 15# Î¨∏ÌôîÏû¨Îã® 15%
        community_pool:50# Ïª§ÎÆ§ÎãàÌã∞ ÌíÄ5%
    }
    
    # ÏùåÏïÖ NFT ÏÉùÏÑ±
    nft_metadata = nft_manager.create_music_nft(
        user_id="user_123",
        biometric=biometric,
        cultural=cultural,
        social=social,
        facial=facial,
        voice=voice,
        user_intention="Í±¥Í∞ïÌïú Î™∏Í≥º ÎßàÏùåÏùÑ ÏúÑÌïú ÌèâÌôîÎ°úÏö¥ Î™ÖÏÉÅ",
        ownership_structure=ownership_structure
    )
    
    print(üéµ Ï¥àÍ∞úÏù∏Ìôî ÏùåÏïÖ NFT ÏÉùÏÑ± ÏôÑÎ£å!)    print(f"NFT ID: {nft_metadata['nft_id]}")
    print(f"ÏùåÏïÖ Ïä§ÌÉÄÏùº: {nft_metadata['music_data'][music_style]})
    print(fÌÖúÌè¨: {nft_metadata[music_data]['tempo']} BPM)
    print(f"Í∞êÏ†ïÏ†Å ÌÜ§: {nft_metadata['music_data]['emotional_tone]})
    print(f"ÏïÖÍ∏∞: {', '.join(nft_metadata['music_data']['instruments])})
    print(f"Ï¥ù ÏßÄÎ∂Ñ: {nft_metadata['total_shares]}%")
    print(f"Í≥†Ïú† ÏÑúÎ™Ö: {nft_metadata['music_data']['unique_signature'][:16]}...)   
    # ÏÇ¨Ïö©ÏûêÏùò NFT Î™©Î°ù Ï°∞Ìöå
    user_nfts = nft_manager.get_user_nfts("user_123)
    print(f"\nÏÇ¨Ïö©Ïûê NFT Í∞úÏàò: {len(user_nfts)})
    
    return nft_metadata

if __name__ == "__main__":
    demo_personalized_music_nft() 